# 序列问题

* 递归计算一个整数数组的和、最大值、平均值。

  ```c++
  // 递归计算数组的和
  int sum_r(int a[], int n) {
      if (n == 1) {
          return a[0];
      }
  
      return a[n-1] + sum_r(a, n-1);
  }
  
  // 递归求一个数组中元素最大值
  int max_r(int a[], int n) {
      if (n == 1) {
          return a[0];
      }
  
      return max<int>(a[n-1], max_r(a, n-1));
  }
  
  // 递归计算数组中元素的平均数
  double average_r(int a[], int n) {
      if ( n == 1 ) {
          return a[0];
      }
  
      return (double)(a[n-1] + (n-1) * average_r(a, n-1))/n;
  }
  
  int main()
  {
      int a[6] = {1, 3, 15, 4, 10, 7};
      cout << "sum=" << sum_r(a, 6) << endl;
      cout << "max_r=" << max_r(a, 6) << endl;
      cout << "avarage_r=" << average_r(a, 6) << endl;
      return 0;
  }
  ```

* 当n很大时计算 sum的值。

  sum = 1-2+3-3+5-6+7-8... + n-1+n;

  ```c++
  // 分析：此题可以用迭代法或者递归法求解，但是题目中说了n很大，所以可以直接推导通项公式求解。
  // 当n为偶数时 sum=(1-2)+(3-4)+...[(n-1)-n] = (-1)*(n/2)
  // 当n为奇数时，sum=(1-2)+(3-4)+...[(n-2)-(n-1)]+n = (-1)(n-1/2)+n
  
  int func(int n) {
      if (n%2 == 0) {
          return (-1)*(n/2);
      } else {
          return (-1)*((n-1)/2) + n;
      }
  }
  ```

  

* 不使用额外的变量，交换两个整数的值。

  ```c++
  int main()
  {
      int a = 10, b = 12;
      // 第一种方法
      a = a + b;
      b = a - b;
      a = a - b;
  
      // 第二种方法
      a = a^b;
      b = a^b;
      a = a^b;
  
      return 0;
  }
  ```



* 不使用任何条件判断语句（如if、三目，switch等），判断两个整数中哪个最大？

  ```c++
  // 分析：a、b两个数中最大的数等于(a+b+|a-b|)/2
  int main()
  {
      int a = 10, b = 3;
      int max = (a+b+abs(a-b))/2;
  
      if (max == a) {
          cout << "max is a" << endl;
      } else {
          cout << "max is b" << endl;
      }
  
      return 0;
  }
  ```

  

* 编译器的贪婪策略，总是从左向右扫描得到最大可能的操作数。

  ```c++
  int main()
  {
      int a = 3, b = 7, c;
      c = a+++b;                  // 等价于 c = (a++)+b
      cout << "a=" << a << endl;  // 4
      cout << "b=" << b << endl;  // 7
      cout << "c=" << c << endl;  // 10
  
      return 0;
  }
  ```

  

* 最大的无符号整型怎么表达？

  ```c++
  int main()
  {
      // 无符号整形最大值其实就是32个1 bit，以下两种表达等价
      cout << ~((unsigned int)0) << endl;     // 4294967295
      unsigned int c = -1;  // 32个1
      cout << c << endl;                      // 4294967295 = 2^32-1
  
      system("pause");
      return 0;
  }
  ```

  

* sizeof和strlen

  ```c++
  int main()
  {
      char p[]= "world";
      cout << sizeof(p) << endl;   // sizeof运算符，计算局部变量p占栈空间的字节数，包括\0--- 6
      cout << strlen(p) << endl;   // strlen库函数，计算字符串实际长度，不包括\0  --- 5
  
      char *p1 = "world1";
      cout << sizeof(p1) << endl;  // 这里p被看成指针，64位系统一个指针占8个字节  --- 8
      return 0;
  }
  ```

  

* c++中的 重写（override）、重载（overload）、覆盖。

  * 重写是继承关系中的虚函数，函数**名称、参数个数、参数类型、返回值类型**一致。（多态、运行时绑定、虚函数表）
  * 覆盖是继承关系中**没有写virtual关键字**的重写，就是覆盖了，不构成多态调用。
  * 重载不需要继承关系，指**函数名相同，参数类型和个数不同，返回值可相同可不同**。

  ```c++
  // --------------------重写（override）---------------------------
  class animal {
  public:
      virtual ~animal() {};
      virtual void bark() = 0;     // 纯虚函数，虚基类
  };
  
  class cat : public animal {
  public:
      virtual void bark() {    // virtual关键词是隐式继承的，子类中可以省略
          cout << "cat bark ..." << endl;
      }
  };
  
  class dog : public animal {
  public:
      virtual void bark() {
          cout << "dog bark ..." << endl;
      }
  };
  
  // --------------------重载（overload）--------------------------
  int add(int a, int b) {
      return a+b;
  }
  const int MIN = 1e-8;
  bool add(double d) {
      if ( fabs(d) <=MIN ) {
          return true;
      }
      return false;   // 输入值非0 返回真   
  }
  
  int main()
  {
      animal *a = new cat();
      a->bark();                // cat bark 
      a = new dog();
      a->bark();                // dog bark
  
      cout << add(0.0) << endl;   // 调用bool sum(double d) 版本，输出1
      cout << add(1, 2) << endl;  // 调用int sum(int int)版本，输出3
  
      return 0;
  }
  ```

* 用变量表示数组长度

  传统上的C语言是不支持变长数组功能的，也就是说数组的长度是在编译期就确定下来的，不能在运行期改变（常量的值在编译时就能得到，而变量的值在运行时才能确定）。不过，在C99标准中，新增的一项功能就是允许在C语言中使用变长数组。然而，C99定义的这种变长数组的使用是有限制的（应该必须是编译器就能确定值才行），不能像在C++等语言中一样自由使用。

  以下代码在c++11中编译过，但是在某些低版本的编译器中就编译不过...

  ```c++
  const int n1 = 10;   // 编译时就确定了 size=10
      int a1[n1] = {0};
      cout << sizeof(a1) << endl;  // --- 40
  
      int n2 = sizeof(int*);  // 编译时就确定了 size=8
      int a2[n2] = {1};
      cout << sizeof(a2) << endl;  // --- 32
  
      int n3;                // 编译时不确定大小
      cin >> n3;             // 键入10
      int a3[n3] = {2};
      cout << sizeof(a3) << endl;     // --- 40
  ```

# 类构造函数的调用顺序

  类B继承自类A, 类B中组合了类C;
  class B:public A{}  
  class B { private: C c;}   
  1. 先调用父类的构造函数，再调用子类的构造函数；  
  2. 先调用内嵌对象的构造函数，调用顺序按照内嵌对象在组合类的定义中出现的次序。在调用该类的构造函数。  
  3. 因此，顺序是 A > C > B  

# 如何判断一个无符号整数的二进制只有一个1？

  * 如何计算无符号整数中1的个数？
    1. 查表法，空间换时间；由于会耗费很多空间，可以定义 char data[256]的表，然后分成四段查。
    2. 位与运算

       ```c++
        int getOneNum(int data) {
            int sum = 0;
            while(data>0) {
                sum += (data & 1);
                data >>= 1;
            }
            return sum;
        }
        ```

# 智能指针share_ptr 是线程安全的吗？

  1. 同一个shared_ptr对象可以被多线程同时读取。（并发读是线程安全的，如get操作）  
  2. 同一个shared_ptr对象不能被多线程直接修改，但可以通过原子函数完成。（并发写是不安全的，如reset操作，需要加锁，boost库和c++11中的原子函数本质也是加锁）。

# 类型转换函数

  * const_cast <new_type> (expression)：同种类型间转换，移除/添加变量的const/volatile属性。
  * reinterpret_cast <new_type> (expression)：reinterpret即为重新解释，此标识符的意思即为数据的二进制形式重新解释，但是不改变其值。用于任何类型间转换，而无须考虑类型安全或者常量的情形。不到万不得已绝对不用。
  * static_cast<new_type> (expression)：将一个值以符合逻辑的方式进行转换，即，利用原值重建一个临时对象，并在设立初值时使用类别转换。
  * dynamic_cast<new_type> (expression)：将多态类型向下转型（downcast）为其实际静态类型（real static type）。其他三种是编译时确定的，这种是运行时确定的。
  在类的转换时，在类层次间进行上行（将父类指针转化子类指针）转换时，dynamic_cast和static_cast的效果是一样的。在进行下行（子类指针指向父类指针）转换 时，dynamic_cast具有类型检查的功能，比static_cast更安全。
  * 小结：
    * 去const属性用const_cast。
　　* 基本类型转换用static_cast。
　　* 多态类之间的类型转换用daynamic_cast。
　　* 不同类型的指针类型转换用reinterpreter_cast。

# C++类内数据成员类型

  * 可以定义引用类型，必须通过成员函数初始化列表初始化。
  * 类内const成员，只能在构造函数后的初始化列表中初始化（c98标准），c++11中，常量数据成员可以在类内初始化，在声明类的时候进行类内初始化，因此该类内常量的作用域属于类级，即该类的所有对象均具有同一个值。
  * 类的static成员：初始化在类外，且初始化时不用加static修饰。
  * 类的const static成员：类只有唯一一份拷贝，且数值不能改变。因此，可以在类中声明处初始化，也可以像static在类外初始化。

# C++函数栈空间的最大值 ？

  默认是1M，不过可以调整。

# c++中的锁

  * 互斥量 pthread_mutex_t（锁） 基本的、定时的、递归的
  * 条件变量 pthread_cond_t（同步）
  * 自旋锁：互斥量阻塞时休眠，自旋锁阻塞时忙等。
  * 读写锁：pthread_rwlock_t，一次只有一个线程可以占有写模式的读写锁，但多个线程可以同时占有读模式的读写锁。

  * 避免死锁，可以使用pthread_cond_timewait

# c语言函数调用过程?
  栈帧结构、参数压栈（从右向左）、函数调用call 。。。继续
  了解函数调用过程进一步认识递归调用

# where和having的区别
  where和having都是用来筛选的，后面跟的都是筛选条件，只不过where筛选的是原始的表数据；having筛选的是分组（group by）后的组数据，是对查询结果集的过滤。
  having不能单独使用，只能和group by连用，但用group by不一有having （它只是一个筛选条件用的，取决于是否要对分组数据进行筛选）。

# mysql数据库的四种隔离级别
  ACID：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）
# 一种思想：递归 = 栈 + 循环
