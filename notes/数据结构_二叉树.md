[TOC]

# 二叉树

​	**基本思想**：递归



#二叉树遍历
* 先序：根-左子树-右子树

* 后序：左子树-右子树-根

* 中序：左子树-根-右子树

* 树节点结构：

  ```c++
  #include <stdio.h>
  #include <stdlib.h>

  typedef struct BINode
  {
      char ch;
      struct BINode * lchild;
      struct BINode * rchild;    
  }BiNode;
  ```

  ​

* 递归遍历：

  ```c++
  #include <stdio.h>
  #include <stdlib.h>

  typedef struct BINode
  {

      char ch;
      struct BINode * lchild;
      struct BINode * rchild;    

  }BiNode;

  // 递归 - 后序遍历二叉树(先序遍历和中序遍历类似的)
  void postRecursion(BiNode *root) {
      if(root == NULL) {
          return;
      }
      // 先遍历左节点
      postRecursion(root->lchild);
      // 再遍历右节点
      postRecursion(root->rchild);
      // 再遍历根节点
      printf("%c ", root->ch);

  }

  void creatTree() {

       BiNode nodeA = {'A', NULL, NULL};
       BiNode nodeB = {'B', NULL, NULL};
       BiNode nodeC = {'C', NULL, NULL};
       BiNode nodeD = {'D', NULL, NULL};
       BiNode nodeE = {'E', NULL, NULL};
       BiNode nodeF = {'F', NULL, NULL};
       BiNode nodeG = {'G', NULL, NULL};
       BiNode nodeH = {'H', NULL, NULL};
      
       nodeA.lchild = &nodeB;
       nodeA.rchild = &nodeF;
       nodeB.rchild = &nodeC;
       nodeC.lchild = &nodeD;
       nodeC.rchild = &nodeE;
       nodeF.rchild = &nodeG;
       nodeG.lchild = &nodeH;
       
       postRecursion(&nodeA);  

  }

  int main(){

      creatTree();
      system("pause");
      return 0;

  }
  ```

  ​

# 计算叶子节点个数
```c++
  int num=0;
  void CaculateLeafNum(BiNode *root) {
      if (root == NULL) {
          return;
      }
      if(root->lchild == NULL && root->rchild == NULL) {
          num++;
      }
      // 计算左子树的叶子节点
      CaculateLeafNum(root->lchild);
      // 计算右子树的叶子节点
      CaculateLeafNum(root->rchild);
  }
```



# 计算二叉树的高度
```c++
int Height(BiNode *root) {

    if(root == NULL) {
        return 0;
    }
    
    int rheight = Height(root->lchild);
    int lheight = Height(root->rchild);
    
    return lheight > rheight ? lheight + 1 : rheight + 1;
}
```



# 二叉树的拷贝和释放

```c++
BiNode *CopyBiTree(BiNode *root) {

    if(root == NULL) {
        return NULL;
    }
    // 拷贝左子树
    BiNode *newlchild = CopyBiTree(root->lchild);
    // 拷贝右子树
    BiNode *newrchild = CopyBiTree(root->rchild);
    // 拷贝当前节点
    BiNode *newroot = (BiNode *)malloc(sizeof(BiNode));
    newroot->lchild = newlchild;
    newroot->rchild = newrchild;
    newroot->ch = root->ch;
    return newroot;

}

void DestroyBiTree(BiNode *root) {

    if(root == NULL) {
        return;
    }
    // 释放左子树
    DestroyBiTree(root->lchild);
    // 释放右子树
    DestroyBiTree(root->rchild);
    // 释放根节点
    free(root);

}
```



# 二叉树的非递归遍历

* 利用栈实现
  视频：https://www.bilibili.com/video/av20126584/?p=44

  ```c++
  void preOrder(Node*root)
  {
      stack<node>st;
      st.push(root);
      Node* tem = NULL;
      while (!st.empty())
      {
      	tem = st.top();
      	st.pop();
      	if (tem != NULL)
      	{
      		cout << tem->data << " ";
      		st.push(tem->Left);
      		st.push(tem->Right);
      	}
      }

  }
  ```

  ​


# 如何确定一棵树
* 如何确定一棵树

  * 中序+先序 可以确定一棵树
  * 中序+后序 可以确定一棵树

  技巧：必须带中序遍历！！！

* 根据先序遍历和中序遍历确定一棵树？
  先序：ADEBCF
  中序：DEACFB
  思路：
  根据先序遍历可知根节点A,根据中序结果，可知根的左子树DE，右子树CFB；
  左子树：先序是DE,中序是DE =>E是D的右子树；
  右子树：先序BCF，中序CFB =>B是根节点，F是C的右边节点
  ==> 后序：EDFCBA


# 如何创建一棵树
```c++
// 先序创建一棵树，ABD##E##C##，#代表空节点
Bitree CreateBitree(Bitree T)//先序创建一颗二叉树
{
  char  e;
  scanf_s("%c", &e);
  fflush(stdin);

  if (e != '#'){
    //判断当前输入的字符
    T = (Bitree)malloc(sizeof(Tree)); //分配存贮空间
    T->data = e;
    T->lchild = NULL;
    T->rchild = NULL;
    T->lchild = CreateBitree(T->lchild); //递归创建左孩子节点值
    T->rchild = CreateBitree(T->rchild);   //递归创建右孩子节点值
 }

 return T;
}
```

