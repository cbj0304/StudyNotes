[TOC]

# 设计模式

# 面向对象三大特性

* 封装性

  封装就是把抽象的数据和对数据进行的操作封装在一起。（保护、隔离）

* 继承性

  从已有类得到继承信息创建新类的过程。（代码复用）

* 多态性

  父类对象的引用或指针指向不同的子类对象时，调用同样的方法但是做了不同的事情。（多种状态）  
  overload：重载（同一个类中，函数名相同，参数类型和个数不同）：实现编译时多态，即前绑定。  
  override：重写（子类对父类中的虚函数的具体实现进行修改）：实现运行时绑定，即后绑定。  

# 面向对象的八大设计原则

## 依赖倒置原则

* 程序要依赖于抽象接口，不要依赖于具体实现。  
  高层模块（稳定）不应该依赖于低层模块（变化），二者都应该依赖于抽象（稳定）；  

  > AutoSystem系统（高层业务模块）依赖于ICar 这个抽象，而与具体的实现细节HondaCar、FordCar、BmwCar无关，所以实现细节的变化不会影响AutoSystem。  
* 抽象不应该依赖于实现细节（变化），实现细节应该依赖于抽象；  

  > 对于实现细节HondaCar、FordCar、BmwCar 只要实现ICar即可，即实现细节依赖于ICar抽象。  
* 代码示例：  

  ```c++
  // 抽象接口类
  class ICar
  {
  public:
      virtual void Run() = 0;
      virtual void Turn() = 0;
      virtual void Stop() = 0;
  };

  // 具体实现 - 宝马车
  class BmwCar : public ICar
  {
  public:
      void Run() {
          cout << "BmwCar run" << endl;
      }
      void Turn() {
          cout << "BmwCar turn" << endl;
      }
      void Stop() {
          cout << "BmwCar stop" << endl;
      }
  };

  // 具体实现 - 福特车
  class FordCar : public ICar
  {
  public:
      void Run() {
          cout << "FordCar run" << endl;
      }
      void Turn() {
          cout << "FordCar turn" << endl;
      }
      void Stop() {
          cout << "FordCar stop" << endl;
      }
  };
  /*
  如果增加车的品牌，只需要实现这个具体车型即可
  class HondaCar : public ICar
  {
  public:
  };*/

  // 高层控制模块
  class AutoSystem
  {
  private:
      ICar *_icar;

      void RunCar() {
          _icar->Run();
      }
      void TurnCar() {
          _icar->Turn();
      }
      void StopCar() {
          _icar->Stop();
      }
  public:
      AutoSystem(ICar* icar) {
          this->_icar = icar;
      }
      void testCar() {
          RunCar();
          TurnCar();
          StopCar();
      }
  };

  int main()
  {
      // 多态调用（动态绑定）
      ICar *car = new BmwCar();
      AutoSystem au = AutoSystem(car);
      au.testCar();
      system("pause");
      return 0;
  }
  ```

## 开放封闭原则（OCP)

​   对扩展开放，对修改封闭；

## 单一职责原则

​   一个类应该仅有一个引起变化的原因；变化的方向隐含着类的责任；

## 里氏（Liskov）替换原则

* **定义**：父类出现的地方可以被子类替换，在替换后依然保持原功能。  
* **实现**：子类必须完全实现父类的方法。子类拥有父类的所有功能。  
* **作用**：增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。在实际项目中，每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑（多态）。  

## 接口隔离原则

​   客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。使用多个专门的接口比使用单一的总接口要好。  

## 优先使用对象组合，而不是类继承

​   继承和组合都能达到一个代码复用的效果，但是类的继承通常是白箱复用，对象组合通常为黑箱复用。
我们在使用继承的时候同时也就拥有了父对象中的保护成员，增加了耦合度。  
而对象组合就只需要在使用的时候接口稳定，耦合度低。  
继承（is a）  
组合（has a）  

## 封装变化点

​   将系统中经常变化的部分和稳定的部分隔离，有助于增加复用性，并降低系统耦合度。  

## 针对接口编程，而不是针对实现编程

* **本质**：多态性的运用。
  接口（如虚基类），定义了一堆空方法，是对其全部实现类的约束，具体的实现类必须实现接口事先规定的方法，已使得再操纵父类接口（指向子类实现）时，获得种操作上的一致性（多态），而忽视其子类具体实现上的差异。而针对接口编程，传递的则是父类引用/指针，这样便可发挥多态性“父类引用指向子类对象”的特点和优势；  
  针对实现编程：Dog \*pDog = new DogClass(); pDog.Bark();  
  针对接口编程：Animal \*pAnimal = new DogClass(); pAnimal.Bark();  

* **代码示例**：
  
  ```c++
  #include < iostream>
  #include < cstdlib>

  using namespace std;

  // 抽象接口
  class Animal{
  public:
      virtual void Bark() = 0;
  };

  // 具体实现Dog
  class Dog : public Animal {
  public:
      void Bark(){
          cout << "dog bark..." << endl;
      }
  };

  // 具体实现Cat
  class Cat : public Animal {
  public:
      void Bark() {
          cout << "cat bark..." << endl;
      }
  };

  int main(){
      // 多态调用
      Animal *pAnimal = new Dog();
      pAnimal->Bark();  

      system("pause");
      return 0;
  }
  ```

# 面向对象的23种设计模式

## 创建型模式（5种）

​   对象实例化的模式，用于解耦对象的实例化过程。

### 工厂模式

* 头文件

```c++
// factorymethod.h
#include < iostream>
#include < cstdlib>

using namespace std;

//=============================抽象基类
class ISplitter{
public:
    virtual void split()=0;
    // 抽象基类必须自定义抽象的析构函数
    virtual ~ISplitter(){}
};

//=============================抽象工厂基类
class SplitterFactory{
public:
    virtual ISplitter* CreateSplitter()=0;
    virtual ~SplitterFactory(){}
};

//=============================具体类
// 二进制文件分割器
class BinarySplitter : public ISplitter{
   void split() { cout << "BinarySplitter..." << endl; }
};

// 文本文件分割器
class TxtSplitter: public ISplitter{
   void split() { cout << "TxtSplitter..." << endl; }
};

// 图片分割器
class PictureSplitter: public ISplitter{
   void split() { cout << "PictureSplitter..." << endl; }
};

class VideoSplitter: public ISplitter{
   void split() { cout << "VideoSplitter..." << endl; }
};

//=============================具体工厂方法
class BinarySplitterFactory: public SplitterFactory{
public:
    virtual ISplitter* CreateSplitter(){
        return new BinarySplitter();
    }
};

class TxtSplitterFactory: public SplitterFactory{
public:
    virtual ISplitter* CreateSplitter(){
        return new TxtSplitter();
    }
};

class PictureSplitterFactory: public SplitterFactory{
public:
    virtual ISplitter* CreateSplitter(){
        return new PictureSplitter();
    }
};

class VideoSplitterFactory: public SplitterFactory{
public:
    virtual ISplitter* CreateSplitter(){
        return new VideoSplitter();
    }
};
```

* 源文件

```c++
// factorymethod.cpp
#include "1_factorymethod.h"

class MainForm
{
    SplitterFactory*  factory;//工厂

public:
    MainForm(SplitterFactory*  factory){
        this->factory=factory;
    }

    void ButtonClick(){
        ISplitter * splitter=
            factory->CreateSplitter(); //多态new

        splitter->split();

    }
};

int main()
{

    MainForm m1(new PictureSplitterFactory());
    m1.ButtonClick();

    MainForm m2(new TxtSplitterFactory());
    m2.ButtonClick();

    // TODO 考虑堆资源释放 delete
    system("pause");
    return 0;
}
```

### 抽象工厂模式

```c++
// abstract.cpp
#include < iostream>
#include < vector>
using namespace std;

//数据库访问有关的基类
class IDBConnection{

};

class IDBCommand{

};

class IDataReader{
public:
    virtual void read() { cout << "IDataReader" << endl; }
};

class IDBFactory{
public:
    virtual IDBConnection* CreateDBConnection()=0;
    virtual IDBCommand* CreateDBCommand()=0;
    virtual IDataReader* CreateDataReader()=0;

   IDBFactory() {}
    virtual ~IDBFactory() {}
};

//支持SQL Server
class SqlConnection: public IDBConnection{

};
class SqlCommand: public IDBCommand{

};
class SqlDataReader: public IDataReader{
    void read() { cout << "SqlDataReader" << endl; }
};

class SqlDBFactory:public IDBFactory{
public:
    IDBConnection* CreateDBConnection() {
        return new SqlConnection();
    }
    IDBCommand* CreateDBCommand() {
        return new SqlCommand();
    }
    IDataReader* CreateDataReader() {
        return new SqlDataReader();
    }

    SqlDBFactory() {}
    ~SqlDBFactory() {}
};

//支持Oracle
class OracleConnection: public IDBConnection{

};

class OracleCommand: public IDBCommand{

};

class OracleDataReader: public IDataReader{
    void read() { cout << "OracleDataReader" << endl; }
};

class OracleDBFactory:public IDBFactory{
public:
    IDBConnection* CreateDBConnection() {
        return new OracleConnection();
    }
    IDBCommand* CreateDBCommand() {
        return new OracleCommand();
    }
    IDataReader* CreateDataReader() {
        return new OracleDataReader();
    }

    OracleDBFactory() {}
    ~OracleDBFactory() {}
};

class EmployeeDAO {
    IDBFactory* m_dbFactory;

public:

    EmployeeDAO(IDBFactory* dbFactory) {
        this->m_dbFactory=dbFactory;
    }
    vector<int> GetEmployees(){
        IDBConnection* connection =
            m_dbFactory->CreateDBConnection();
        // connection->ConnectionString("...");

        IDBCommand* command =
            m_dbFactory->CreateDBCommand();
        // command->CommandText("...");
        // command->SetConnection(connection); //关联性

        IDataReader* reader =
            m_dbFactory->CreateDataReader(); //关联性
        // read ...
    }
};

int main()
{
    IDBFactory *idf = new OracleDBFactory();
    IDataReader* ir = idf->CreateDataReader();
    ir->read();
    // EmployeeDAO dao(idf);
    // dao.GetEmployees();

    if(idf) {
        delete idf;
    }

    return 0;
}
```

### 单例模式（singleton）

* c++单例模式分为两种：懒汉模式和饿汉模式  

  * 懒汉模式：第一次用的时候才会创建，线程不安全  
  * 饿汉模式：一开始就加载，空间换时间，每次用的时候直接返回，线程安全  
  * 还有一种方式是在懒汉基础上加锁、double-check的方式，这中方式由于cpu指令reorder会导致不可预知的问题，不推荐  

  **头文件：**

  ```c++
  // singleton.h
  #include < iostream>
  using namespace std;

  // c++单例模式分为两种：懒汉模式和饿汉模式
  // 懒汉模式：第一次用的时候才会创建，线程不安全
  // 饿汉模式：一开始就加载，空间换时间，每次用的时候直接返回，线程安全
  // 还有一种方式是在懒汉基础上加锁、double-check的方式，这中方式由于cpu指令reorder会导致不可预知的问题，不推荐

  // 懒汉（线程不安全）
  class Singleton_ {
  private:
      Singleton_() {}
      static Singleton_ *single_;
  public:
      static Singleton_* GetInstance() {
          if (single_ == NULL) {
              single_ = new Singleton_();
          }
          return single_;
      }
      void print(int data) {
          cout << "Singleton_ print => " << data << endl;
      }
  };

  // Singleton_ * Singleton_::single_ = NULL;

  // 饿汉（线程安全）

  class Singleton {
  private:
      // 构造函数私有化
      Singleton() {}
      static Singleton *single;

  public:
      static Singleton* GetInstance() {
          return single;
      }

      void print(int data) {
          cout << "Singleton_ print => " << data << endl;
      }
  };

  // Singleton *Singleton::single = new Singleton();
  ```

  **源文件：**

  ```c++
  // singleton.cpp
  #include "3_singleton.h"
  #include < pthread.h>
  #include < cstdlib>

  // 懒汉初始化
  Singleton_ *Singleton_::single_ = NULL;

  // 饿汉初始化
  Singleton *Singleton::single = new Singleton();

  void *threadFunc(void * arg){
      int* pnum = (int *)arg;
      Singleton::GetInstance()->print(*pnum);
      return (void *)0;
  }

  int main(int argc, char* argv[])
  {
      pthread_t tids[5];
      int thread_data[5]={111, 222, 333, 444, 555};
      for(int i = 0; i < 5; ++i) {
          int ret = pthread_create(&tids[i], NULL, threadFunc, (void *)(&thread_data[i]));
          if(ret) {
              cout << "pthread err:" << i << endl;
              return -1;
          }
      }

      for (int j = 0; j < 5; ++j) {
          pthread_join(tids[j], NULL);
      }

      system("pause");
      return 0;
  }
  ```

### 建造者模式

```c++
// builder.cpp
#include < iostream>
using namespace std;

// 基类
class House {
    //....
};

// 基类builder
class HouseBuilder {
public:
    House* GetResult() {
        return pHouse;
    }
    virtual ~HouseBuilder(){}

    House* pHouse;
    virtual void BuildPart1()=0;
    virtual void BuildPart2()=0;
    virtual bool BuildPart3()=0;
    virtual void BuildPart4()=0;
    virtual void BuildPart5()=0;

};

// 具体类
class StoneHouse: public House{

};

// 具体类的builder
class StoneHouseBuilder: public HouseBuilder{
public:

    virtual void BuildPart1(){
        cout << "StoneHouseBuilder BuildPart1..." << endl;
    }
    virtual void BuildPart2(){
        cout << "StoneHouseBuilder BuildPart2..." << endl;
    }
    virtual bool BuildPart3(){
        cout << "StoneHouseBuilder BuildPart3..." << endl;
        return true;
    }
    virtual void BuildPart4(){
        cout << "StoneHouseBuilder BuildPart4..." << endl;
    }
    virtual void BuildPart5(){
        cout << "StoneHouseBuilder BuildPart5..." << endl;
    }

};

class HouseDirector{

public:
    HouseBuilder* pHouseBuilder;

    HouseDirector(HouseBuilder* pHouseBuilder){
        this->pHouseBuilder=pHouseBuilder;
    }

    House* Construct(){

        pHouseBuilder->BuildPart1();

        for (int i = 0; i < 4; i++){
            pHouseBuilder->BuildPart2();
        }

        bool flag=pHouseBuilder->BuildPart3();

        if(flag){
            pHouseBuilder->BuildPart4();
        }

        pHouseBuilder->BuildPart5();

        return pHouseBuilder->GetResult();
    }
};

int main()
{
    HouseBuilder* pHB = new StoneHouseBuilder();
    HouseDirector hd(pHB);
    hd.Construct();

    // 释放堆内存
    if (pHB) {
        delete pHB;
    }
    return true;
}
```

### 原型模式

**头文件：**

```c++
// prototype.h
#include < iostream>
using namespace std;

//抽象类
class ISplitter{
public:
    virtual void split()=0;
    virtual ISplitter* clone()=0; //通过克隆自己来创建对象

    virtual ~ISplitter(){}
};

//具体类
class BinarySplitter : public ISplitter{
public:
    virtual ISplitter* clone(){
        cout << "BinarySplitter clone..." << endl;
        return new BinarySplitter(*this);
    }

    virtual void split() {
        cout << "BinarySplitter split..." << endl;
    }
};

class TxtSplitter: public ISplitter{
public:
    virtual ISplitter* clone(){
        cout << "TxtSplitter clone..." << endl;
        return new TxtSplitter(*this);
    }

    virtual void split() {
        cout << "TxtSplitter split..." << endl;
    }
};

class PictureSplitter: public ISplitter{
public:
    virtual ISplitter* clone(){
        cout << "PictureSplitter clone..." << endl;
        return new PictureSplitter(*this);
    }

    virtual void split() {
        cout << "PictureSplitter split..." << endl;
    }
};
```

**源文件：**

```c++
// prototype.cpp
#include "prototype.h"

class MainForm
{
    ISplitter*  prototype;//原型对象

public:

    MainForm(ISplitter* prototype){
        this->prototype=prototype;
    }

    void ButtonClick(){

        ISplitter * splitter = prototype->clone(); //克隆原型

        splitter->split();
    }
};

int main()
{
    ISplitter *is = new PictureSplitter();
    MainForm mf(is);

    mf.ButtonClick();

    delete is;
    return 0;
}
```

## 结构型模式（7种）

​   把类或对象结合在一起形成一个更大的结构。

### 适配器模式

```c++
// adapter.cpp
#include < iostream>
using namespace std;

//目标接口（新接口）
class ITarget{
public:
    virtual void process()=0;
};

//遗留接口（老接口）
class IAdaptee{
public:
    virtual void foo(int data)=0;
    virtual int bar()=0;
};

//遗留类型
class OldClass: public IAdaptee{
    virtual void foo(int data) {
        cout << "old foo.. data="  << data << endl;
    }

    virtual int bar() {
        cout << "old bar..." << endl;
        return 10;
    }
};

//对象适配器(继承自ITarget，就要实现ITarget的接口规范)
class Adapter: public ITarget{ //继承
protected:
    IAdaptee* pAdaptee;//组合

public:

    Adapter(IAdaptee* pAdaptee){
        this->pAdaptee=pAdaptee;
    }

    virtual void process(){
        int data=pAdaptee->bar();
        pAdaptee->foo(data);
    }
};

int main(){
    IAdaptee* pAdaptee=new OldClass();
    ITarget* pTarget=new Adapter(pAdaptee);
    pTarget->process();
}
```

### 装饰器模式

```c++
// decorator.cpp
#include <iostream>
using namespace std;

// 文件流、网络流、内存流 都继承自流基类  <- 抽象
// 加密、缓存 都是对流的修饰              <- 装饰
// 装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，比继承更灵活。动态给一个对象增加（撤销）功能。
// 实现：继承(is a) + 组合(has a)

//业务操作
class Stream{

public:
    virtual char Read(int number)=0;
    virtual void Seek(int position)=0;
    virtual void Write(char data)=0;

    virtual ~Stream(){}
};

//主体类
class FileStream: public Stream{
public:
    virtual char Read(int number){
        //读文件流
        cout << "File Read..." << endl;
    }
    virtual void Seek(int position){
        //定位文件流
        cout << "File Seek..." << endl;
    }
    virtual void Write(char data){
        //写文件流
        cout << "File Write..." << endl;
    }

};

class NetworkStream :public Stream{
public:
    virtual char Read(int number){
        //读网络流
    }
    virtual void Seek(int position){
        //定位网络流
    }
    virtual void Write(char data){
        //写网络流
    }
};

class MemoryStream :public Stream{
public:
    virtual char Read(int number){
        //读内存流
    }
    virtual void Seek(int position){
        //定位内存流
    }
    virtual void Write(char data){
        //写内存流
    }
};

//扩展操作

class DecoratorStream: public Stream{
protected:
    Stream* stream;//...
    DecoratorStream(Stream * stm):stream(stm){  
    }
};

class CryptoStream: public DecoratorStream {

public:
    CryptoStream(Stream* stm):DecoratorStream(stm){

    }

    virtual char Read(int number){

        //额外的加密操作...
        cout << "Crypto Read..." << endl;
        stream->Read(number);//读文件流
    }
    virtual void Seek(int position){
        //额外的加密操作...
        cout << "Crypto Seek..." << endl;
        stream->Seek(position);//定位文件流
        //额外的加密操作...
    }
    virtual void Write(char data){
        //额外的加密操作...
        cout << "Crypto Write..." << endl;
        stream->Write(data);//写文件流
        //额外的加密操作...
    }
};

class BufferedStream : public DecoratorStream{

public:
    // 调用父类的构造函数
    BufferedStream(Stream* stm):DecoratorStream(stm){

    }
    virtual char Read(int number){

        //额外的加密操作...
        cout << "Buffered Read..." << endl;
        stream->Read(number);//读文件流
    }
    virtual void Seek(int position){
        //额外的加密操作...
        cout << "Buffered Seek..." << endl;
        stream->Seek(position);//定位文件流
        //额外的加密操作...
    }
    virtual void Write(char data){
        //额外的加密操作...
        cout << "Buffered Write..." << endl;
        stream->Write(data);//写文件流
        //额外的加密操作...
    }

};

int main(int argc, char* argv[]){
    // 运行时装配
    int num = 100;
    FileStream* s1=new FileStream();
    s1->Read(num);

    CryptoStream* s2=new CryptoStream(s1);
    s2->Read(num);

    BufferedStream* s3=new BufferedStream(s1);
    s3->Read(num);

    return 0;
}
```

### 代理模式

```c++
// proxy.cpp
#include < iostream>

using namespace std;

// 代理模式：为其他对象提供一种代理以控制对这个对象的访问。这样实现了业务和核心功能分离。
// 代理对象和真实对象有相同的接口，可以操作真实对象，也可以附加业务逻辑，对真实对象进行了封装和隔离。
// 应用：远程代理(如rpc)、安全代理（控制真实对象的访问权限）、智能指针（可以处理真实指针外的一些事情）

// 抽象接口
class Subject {
public:
    virtual void Request() = 0;
    virtual ~Subject(){}
};

// 真实对象
class RealSubject : public Subject {
public:
    void Request() { cout << "RealSubject" << endl; }
};

// 代理对象
class Proxy : public Subject {
private:
    RealSubject* realSubject;
public:
    void Request() {
        if (realSubject == NULL) realSubject = new RealSubject();
        // 可以在此处增加对真实对象的特殊处理或复杂的业务规则
        realSubject->Request();
    }
};

int main() {
    Subject* p = new Proxy();
    p->Request(); // RealSubject

    delete p;
    return 0;
}
```

### 外观模式

也叫外观模式，Facade Pattern

### 桥接模式

```c++
// bridge1.cpp
class Messager{
public:
    virtual void Login(string username, string password)=0;
    virtual void SendMessage(string message)=0;
    virtual void SendPicture(Image image)=0;

    virtual void PlaySound()=0;
    virtual void DrawShape()=0;
    virtual void WriteText()=0;
    virtual void Connect()=0;

    virtual ~Messager(){}
};

//平台实现

class PCMessagerBase : public Messager{
public:

    virtual void PlaySound(){
        //**********
    }
    virtual void DrawShape(){
        //**********
    }
    virtual void WriteText(){
        //**********
    }
    virtual void Connect(){
        //**********
    }
};

class MobileMessagerBase : public Messager{
public:

    virtual void PlaySound(){
        //==========
    }
    virtual void DrawShape(){
        //==========
    }
    virtual void WriteText(){
        //==========
    }
    virtual void Connect(){
        //==========
    }
};

//业务抽象

class PCMessagerLite : public PCMessagerBase {
public:

    virtual void Login(string username, string password){

        PCMessagerBase::Connect();
        //........
    }
    virtual void SendMessage(string message){

        PCMessagerBase::WriteText();
        //........
    }
    virtual void SendPicture(Image image){

        PCMessagerBase::DrawShape();
        //........
    }
};

class PCMessagerPerfect : public PCMessagerBase {
public:

    virtual void Login(string username, string password){

        PCMessagerBase::PlaySound();
        //********
        PCMessagerBase::Connect();
        //........
    }
    virtual void SendMessage(string message){

        PCMessagerBase::PlaySound();
        //********
        PCMessagerBase::WriteText();
        //........
    }
    virtual void SendPicture(Image image){

        PCMessagerBase::PlaySound();
        //********
        PCMessagerBase::DrawShape();
        //........
    }
};

class MobileMessagerLite : public MobileMessagerBase {
public:
    virtual void Login(string username, string password){

        MobileMessagerBase::Connect();
        //........
    }
    virtual void SendMessage(string message){

        MobileMessagerBase::WriteText();
        //........
    }
    virtual void SendPicture(Image image){

        MobileMessagerBase::DrawShape();
        //........
    }
};

class MobileMessagerPerfect : public MobileMessagerBase {
public:
    virtual void Login(string username, string password){

        MobileMessagerBase::PlaySound();
        //********
        MobileMessagerBase::Connect();
        //........
    }
    virtual void SendMessage(string message){

        MobileMessagerBase::PlaySound();
        //********
        MobileMessagerBase::WriteText();
        //........
    }
    virtual void SendPicture(Image image){

        MobileMessagerBase::PlaySound();
        //********
        MobileMessagerBase::DrawShape();
        //........
    }
};

void Process(){
        //编译时装配
        Messager *m =
            new MobileMessagerPerfect();
}
```

```c++
// bridge2.cpp
class Messager{
protected:
     MessagerImp* messagerImp;//...
public:
    virtual void Login(string username, string password)=0;
    virtual void SendMessage(string message)=0;
    virtual void SendPicture(Image image)=0;

    virtual ~Messager(){}
};

class MessagerImp{
public:
    virtual void PlaySound()=0;
    virtual void DrawShape()=0;
    virtual void WriteText()=0;
    virtual void Connect()=0;

    virtual MessagerImp(){}
};

//平台实现 n
class PCMessagerImp : public MessagerImp{
public:

    virtual void PlaySound(){
        //**********
    }
    virtual void DrawShape(){
        //**********
    }
    virtual void WriteText(){
        //**********
    }
    virtual void Connect(){
        //**********
    }
};

class MobileMessagerImp : public MessagerImp{
public:

    virtual void PlaySound(){
        //==========
    }
    virtual void DrawShape(){
        //==========
    }
    virtual void WriteText(){
        //==========
    }
    virtual void Connect(){
        //==========
    }
};

//业务抽象 m

//类的数目：1+n+m

class MessagerLite :public Messager {

public:

    virtual void Login(string username, string password){

        messagerImp->Connect();
        //........
    }
    virtual void SendMessage(string message){

        messagerImp->WriteText();
        //........
    }
    virtual void SendPicture(Image image){

        messagerImp->DrawShape();
        //........
    }
};

class MessagerPerfect  :public Messager {

public:

    virtual void Login(string username, string password){

        messagerImp->PlaySound();
        //********
        messagerImp->Connect();
        //........
    }
    virtual void SendMessage(string message){

        messagerImp->PlaySound();
        //********
        messagerImp->WriteText();
        //........
    }
    virtual void SendPicture(Image image){

        messagerImp->PlaySound();
        //********
        messagerImp->DrawShape();
        //........
    }
};

void Process(){
    //运行时装配
    MessagerImp* mImp=new PCMessagerImp();
    Messager *m =new Messager(mImp);
}
```

### 组合模式

```c++
// composite.cpp
#include < iostream>
#include < list>
#include < string>
#include < algorithm>

using namespace std;

class Component
{
public:
    virtual void process() = 0;
    virtual ~Component(){}
};

// 树节点
// 继承 + 组合
// 继承 -- 是为了实现父类定义的接口规范，不继承生死（构造函数和析构函数）
// 组合 -- 是同时包含并处理多个Component 类型
class Composite : public Component{

    string name;
    list<Component*> elements;
public:
    Composite(const string & s) : name(s) {}

    void add(Component* element) {
        elements.push_back(element);
    }
    void remove(Component* element){
        list<Component*>::iterator it = find(elements.begin(), elements.end(), element);
        if (it != elements.end()) {
            elements.erase(it);
        }
    }

    void process(){

        //1. process current node

        //2. process leaf nodes
        cout << "composite process... name=>" << name << endl;  
        list<Component*>::iterator it = elements.begin();
        for (;it != elements.end();it++) {
            (*it)->process(); //多态调用
        }
    }
};

//叶子节点
class Leaf : public Component{
    string name;
public:
    Leaf(string s) : name(s) {}

    void process(){
        //process current node
        cout << "leaf process name=>" << name << endl;
    }
};

void Invoke(Component & c){
    //...
    c.process();
    //...
};

int main()
{

    Composite root("root");
    Composite treeNode1("treeNode1");
    Composite treeNode2("treeNode2");
    Composite treeNode3("treeNode3");
    Composite treeNode4("treeNode4");
    Leaf leaf1("left1");
    Leaf leaf2("left2");
    Leaf leaf3("left3");

    root.add(&treeNode1);
    treeNode1.add(&treeNode2);
    treeNode2.add(&leaf1);

    root.add(&treeNode3);
    treeNode3.add(&treeNode4);
    treeNode4.add(&leaf2);
    treeNode4.add(&leaf3);

    // root -----treeNode1---treeNode2---leaf1
    //      |
    //      | ---treeNode3---treeNode4---leaf2
    //                             |
    //                             |-----leaf3
    Invoke(root);
    Invoke(leaf2);
    Invoke(treeNode3);

    return 0;
}
```

### 享元模式

```c++
// flyweight.cpp
#include < iostream>
#include < map>

using namespace std;

// 享元模式（轻量模式，轻量级细粒度对象）减少创建对象的数量,以减少内存占用和提高性能。
// 一篇文档中如果所有汉字都对应一个字体对象，那么一篇文档所要容纳的对象将是非常庞大且耗费内存的，
// 实际组成文档的字体是有限的，文档是由这些字体的排列组合得到的，因此将有限的字体集共享。

class Font {
private:

    //unique object key
    string key;

    //object state
    //....

public:
    Font(const string& key){
        //...
    }
};

class FontFactory{
private:
    map<string,Font* > fontPool;

public:
    Font* GetFont(const string& key){

        map<string,Font*>::iterator it = fontPool.find(key);

        if(it != fontPool.end()){
            return fontPool[key];
        }
        else{
            Font* font = new Font(key);
            fontPool[key]= font;
            return font;
        }

    }

    void clear(){
        //...
    }
};

int main(int argc, char* argv[])
{
    return 0;
}
```

## 行为型模式（11种）

​   类和对象如何交互，及划分责任和算法。

### 策略模式

```c++
// strategy1.cpp
enum TaxBase {
    CN_Tax,
    US_Tax,
    DE_Tax,
    FR_Tax       //更改
};

class SalesOrder{
    TaxBase tax;
public:
    double CalculateTax(){
        //...

        if (tax == CN_Tax){
            //CN***********
        }
        else if (tax == US_Tax){
            //US***********
        }
        else if (tax == DE_Tax){
            //DE***********
        }
        else if (tax == FR_Tax){  //更改
            //...
        }
        //....
     }
};
```

```c++
// strategy2.cpp
class TaxStrategy{
public:
    virtual double Calculate(const Context& context)=0;
    virtual ~TaxStrategy(){}
};

class CNTax : public TaxStrategy{
public:
    virtual double Calculate(const Context& context){
        //***********
    }
};

class USTax : public TaxStrategy{
public:
    virtual double Calculate(const Context& context){
        //***********
    }
};

class DETax : public TaxStrategy{
public:
    virtual double Calculate(const Context& context){
        //***********
    }
};

//扩展
//*********************************
class FRTax : public TaxStrategy{
public:
    virtual double Calculate(const Context& context){
        //.........
    }
};

class SalesOrder{
private:
    TaxStrategy* strategy;

public:
    SalesOrder(StrategyFactory* strategyFactory){
        this->strategy = strategyFactory->NewStrategy();
    }
    ~SalesOrder(){
        delete this->strategy;
    }

    public double CalculateTax(){
        //...
        Context context();

        double val =
            strategy->Calculate(context); //多态调用
        //...
    }

};
```

### 模板方法模式

```c++
// template1_app.cpp
//应用程序开发人员
class Application{
public:
    bool Step2(){
        //...
    }

    void Step4(){
        //...
    }
};

int main()
{
    Library lib();
    Application app();

    lib.Step1();

    if (app.Step2()){
        lib.Step3();
    }

    for (int i = 0; i < 4; i++){
        app.Step4();
    }

    lib.Step5();

}
```

```c++
// template1_lib.cpp
//程序库开发人员
class Library{

public:
    void Step1(){
        //...
    }

    void Step3(){
        //...
    }

    void Step5(){
        //...
    }
};
```

```c++
// template2_app.cpp
//应用程序开发人员
class Application : public Library {
protected:
    virtual bool Step2(){
        //... 子类重写实现
    }

    virtual void Step4() {
        //... 子类重写实现
    }
};

int main()
    {
        Library* pLib=new Application();
        lib->Run();

        delete pLib;
    }
}
```

```c++
// template2_lib.cpp
//程序库开发人员
class Library{
public:
    //稳定 template method
    void Run(){

        Step1();

        if (Step2()) { //支持变化 ==> 虚函数的多态调用
            Step3();
        }

        for (int i = 0; i < 4; i++){
            Step4(); //支持变化 ==> 虚函数的多态调用
        }

        Step5();

    }
    virtual ~Library(){ }

protected:

    void Step1() { //稳定
        //.....
    }
    void Step3() {//稳定
        //.....
    }
    void Step5() { //稳定
        //.....
    }

    virtual bool Step2() = 0;//变化
    virtual void Step4() =0; //变化
};
```

### 观察者模式

```c++
// Observer1-observer1.cpp
// 观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。
// 这个主题对象在状态上发生 变化时，会通知所有观察者对象，使他们能够自动更新自己。
#include < iostream>
#include < list>

using namespace std;

// 抽象接口（进度条）
class IProgress {
public:
    virtual void DoProgress(float value)=0;
    virtual ~IProgress(){}
};

// 文件分割器，文件分隔完毕后通知所有进度条更新其状态
class FileSplitter
{
    string m_filePath;
    int m_fileNumber;

    list<IProgress*>  m_iprogressList; // 抽象通知机制，支持多个观察者

public:
    FileSplitter(const string& filePath, int fileNumber) :
        m_filePath(filePath),
        m_fileNumber(fileNumber){

    }

    void split(){

        //1.读取大文件

        //2.分批次向小文件中写入
        for (int i = 0; i < m_fileNumber; i++){
            //...

            float progressValue = m_fileNumber;
            progressValue = (i + 1) / progressValue;
            onProgress(progressValue);//发送通知
        }

    }

    void addIProgress(IProgress* iprogress){
        m_iprogressList.push_back(iprogress);
    }

    void removeIProgress(IProgress* iprogress){
        m_iprogressList.remove(iprogress);
    }

protected:
    virtual void onProgress(float value){

        list<IProgress*>::iterator itor=m_iprogressList.begin();

        while (itor != m_iprogressList.end() ) {
            (*itor)->DoProgress(value); //更新进度条
            itor++;
        }
    }
};
```

```c++
// Observer1-mainform.cpp
class MainForm : public IProgress
{
    TextBox* txtFilePath;
    TextBox* txtFileNumber;

    ProgressBar* progressBar;

public:
    void Button1_Click(){

        string filePath = txtFilePath->getText();
        int number = atoi(txtFileNumber->getText().c_str());

        ConsoleNotifier cn;

        FileSplitter splitter(filePath, number);

        splitter.addIProgress(this); //订阅通知
        splitter.addIProgress(&cn)； //订阅通知

        splitter.split();

        splitter.removeIProgress(this);

    }

    virtual void DoProgress(float value){
        progressBar->setValue(value);
    }
};

class ConsoleNotifier : public IProgress {
public:
    virtual void DoProgress(float value){
        cout << ".";
    }
};
```

* c语言用函数指针实现观察者模式

     现在假设有一组原始数据，会有折现图、sheet表以及比例图等三种表现形式，
     观察者模型的思想就是在原始数据有变化后发布一条通知，三种表现形式会同步更新显示，
     原始数据就是Subject，三种表现形式就是Observer，下面使用C语言实现该模型。

```c++
     // Observer2-Subject.h
     #ifndef SRC_SUBJECT_H_
     #define SRC_SUBJECT_H_

     #include "List.h"
     #include "Observer.h"

     typedef struct _Subject Subject;
     typedef struct _Subject* SubjectPtr;
     struct _Subject
    {
        int val;
        struct list_head list;
        void (*add)(SubjectPtr sp, ObserverPtr op);
        void (*remove)(SubjectPtr sp, ObserverPtr op);
        void (*notify)(SubjectPtr sp);
        void (*changeEvent)(SubjectPtr sp, int code);
    };

    void Subject_Init(SubjectPtr sp);

    #endif /* SRC_SUBJECT_H_ */
     ```
     ​

     ```c++
     // Observer2- Subject.c
     #include "Subject.h"

    static void Subject_AddObserver(SubjectPtr sp, ObserverPtr op)
    {
        list_add_tail(&op->node, &sp->list);
    }

    static void Subject_RemoveObserver(SubjectPtr sp, ObserverPtr op)
    {
        list_del(&op->node);
    }

     static void Subject_NotifyObserver(SubjectPtr sp)
     {
        ObserverPtr op;
        list_for_each_entry(op, &sp->list, node)
        {
            op->update(sp->val);
        }
     }

     static void Subject_ChangeEvent(SubjectPtr sp, int code)
     {
        sp->val = code;
     }

     void Subject_Init(SubjectPtr sp)
     {
        sp->add = Subject_AddObserver;
        sp->remove = Subject_RemoveObserver;
        sp->notify = Subject_NotifyObserver;
        sp->changeEvent = Subject_ChangeEvent;
        sp->val = 0;
        INIT_LIST_HEAD(&sp->list);
     }
     ```
     ​

    ```c
    /*
    * Observer.h
    *
    *  Created on: 2019年5月15日
    *      Author: Administrator
    */

    #ifndef SRC_OBSERVER_H_
    #define SRC_OBSERVER_H_

    #include <stdlib.h>
    #include "List.h"

    typedef void(*update_fun_ptr)(int val);

    typedef struct
    {
        update_fun_ptr update;
        struct list_head node;
    }Observer, *ObserverPtr;

    typedef struct
    {
        Observer obs;
        /*
        * 以下是本类独有数据
        */
    }SheetObserver, *SheetObserverPtr;

    typedef struct
    {
         Observer obs;
        /*
        * 以下是本类独有数据
        */
    }ChartObserver, *ChartObserverPtr;

    typedef struct
    {
        Observer obs;
        /*
         * 以下是本类独有数据
         */
    }ScaleObserver, *ScaleObserverPtr;

     void update_sheet(int val);
     void update_chart(int val);
     void update_scale(int val);
     void Observer_Init(ObserverPtr op, update_fun_ptr fptr);

     #endif /* SRC_OBSERVER_H_ */
     ```
     ​

     ```c
     // Observer2- Observer.c
     #include "Observer.h"

     void update_sheet(int val)
     {
        printf("%s: code = %d \r\n", __FUNCTION__, val);
     }

     void update_chart(int val)
     {
        printf("%s: code = %d \r\n", __FUNCTION__, val);
     }

     void update_scale(int val)
     {
        printf("%s: code = %d \r\n", __FUNCTION__, val);
     }

     void Observer_Init(ObserverPtr op, update_fun_ptr fptr)
     {
        op->update = fptr;
        op->node.next = NULL;
        op->node.prev = NULL;
     }
     ```
     ​

     ```c
     // Observer2- main.c
     #include < stdio.h>
     #include "Observer.h"
     #include "Subject.h"

     int main()
     {
        Subject sb;
        SheetObserver sheet;
        ScaleObserver scale;
        ChartObserver chart;

        Subject_Init(&sb);
        Observer_Init(&sheet.obs, update_sheet);
        Observer_Init(&scale.obs, update_scale);
        Observer_Init(&chart.obs, update_chart);

        sb.add(&sb, &sheet.obs);
        sb.add(&sb, &scale.obs);
        sb.add(&sb, &chart.obs);

        sb.changeEvent(&sb, 4);
        sb.notify(&sb);
        printf("\n\n");

        sb.remove(&sb, &scale.obs);
        sb.changeEvent(&sb, 0xFF);
        sb.notify(&sb);

         return 0;
     }
     ```
     ​

### 迭代子模式


```c++
// iterator.cpp
// 迭代器模式：提供一种方法顺序访问一个聚合对象中各个元素，而又不需要暴露该对象的内部表示。
// 设计模式中的迭代器模式有点过时了，可以被stl中的迭代器取代
// stl中泛型编程（模板类 编译时绑定的方案）效率更高

#include < iostream>
using namespace std;

template< typename T>
class Iterator
{
public:
    virtual void first() = 0;
    virtual void next() = 0;
    virtual bool isDone() const = 0;
    virtual T& current() = 0;
};

template< typename T>
class MyCollection{

public:

    Iterator< T> *GetIterator(){
        //...
    }

};

template< typename T>
class CollectionIterator : public Iterator< T>{
    MyCollection< T> mc;
public:

    CollectionIterator(const MyCollection< T> & c): mc(c){ }

    void first()  {

    }
    void next()  {

    }
    bool isDone() const {

    }
    T& current() {

    }
};

void MyAlgorithm()
{
    MyCollection< int> mc;

    Iterator< int> *iter = mc.GetIterator();

    for (iter->first(); !iter->isDone(); iter->next()){
        cout << iter->current() << endl;
    }
}

int main() {
    MyAlgorithm();
    return 0;
}
```

### 责任链模式

```c++
// chainonresponsibility.cpp
#include < iostream>
#include < string>

using namespace std;

namespace DataDefine {
enum RequestType
{
    REQ_HANDLER1,
    REQ_HANDLER2,
    REQ_HANDLER3
};
};

class Reqest
{
    string description;
    DataDefine::RequestType reqType;
public:
    Reqest(const string &desc, DataDefine::RequestType type) : description(desc), reqType(type) {}
    DataDefine::RequestType getReqType() const { return reqType; }
    const string& getDescription() const { return description; }
};

class ChainHandler{
private:
    ChainHandler *nextChain;
    void sendReqestToNextHandler(const Reqest & req)
    {
        if (nextChain != NULL)
            nextChain->handle(req);
    }

public:
    ChainHandler() { nextChain = NULL; }
    void setNextChain(ChainHandler *next) { nextChain = next; }

    virtual bool canHandleRequest(const Reqest & req) = 0;
    virtual void processRequest(const Reqest & req) = 0;

    void handle(const Reqest & req)
    {
        if (canHandleRequest(req))
            processRequest(req);
        else
            sendReqestToNextHandler(req);
    }
};

class Handler1 : public ChainHandler{
protected:
    bool canHandleRequest(const Reqest & req)
    {
        cout << "Handler1 canHandleRequest..." << endl;
        return req.getReqType() == DataDefine::REQ_HANDLER1;
    }
    void processRequest(const Reqest & req)
    {
        cout << "Handler1 is handle reqest: " << req.getDescription() << endl;
    }
};

class Handler2 : public ChainHandler{
protected:
    bool canHandleRequest(const Reqest & req)
    {
        cout << "Handler2 canHandleRequest..." << endl;
        return req.getReqType() == DataDefine::REQ_HANDLER2;
    }
    void processRequest(const Reqest & req)
    {
        cout << "Handler2 is handle reqest: " << req.getDescription() << endl;
    }
};

class Handler3 : public ChainHandler{
protected:
    bool canHandleRequest(const Reqest & req)
    {
        cout << "Handler3 canHandleRequest..." << endl;
        return req.getReqType() == DataDefine::REQ_HANDLER3;
    }
    void processRequest(const Reqest & req)
    {
        cout << "Handler3 is handle reqest: " << req.getDescription() << endl;
    }
};

int main(){
    Handler1 h1;
    Handler2 h2;
    Handler3 h3;
    h1.setNextChain(&h2);
    h2.setNextChain(&h3);

    Reqest req("process task ... ", DataDefine::REQ_HANDLER3);
    h1.handle(req);
    return 0;
}
```

### 命令模式

```c++
// command.cpp
#include < iostream>
#include < vector>
#include < string>
using namespace std;

// 将函数封装为对象，就能够以参数的形式将其传递给其他函数或者对象，告诉它们在旅行请求的过程中执行特定的操作。
// 可以用c++函数对象（重载()运算符）替代

class Command
{
public:
    virtual void execute() = 0;
};

class ConcreteCommand1 : public Command
{
    string arg;
public:
    ConcreteCommand1(const string & a) : arg(a) {}
    void execute()
    {
        cout<< "#1 process..."<<arg<<endl;
    }
};

class ConcreteCommand2 : public Command
{
    string arg;
public:
    ConcreteCommand2(const string & a) : arg(a) {}
    void execute()
    {
        cout<< "#2 process..."<<arg<<endl;
    }
};

class MacroCommand : public Command
{
    vector< Command*> commands;
public:
    void addCommand(Command *c) { commands.push_back(c); }
    void execute()
    {
        vector< Command*>::iterator it = commands.begin();
        for (;it != commands.end(); it++)
        {
            (*it)->execute();
        }
    }
};

int main()
{

    ConcreteCommand1 command1("Arg ###");
    ConcreteCommand2 command2("Arg $$$");

    MacroCommand macro;
    macro.addCommand(&command1);
    macro.addCommand(&command2);

    macro.execute();

    return 0;
}
```

### 备忘录模式

```c++
// memento.cpp
// 备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。
// 备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，
// 从而可以在将来合适的时候把这个对象还原到存储起来的状态。
#include <iostream>
#include <string>
using namespace std;

class Memento
{
    string state;
    //..
public:
    Memento(const string & s) : state(s) {}
    string getState() const { return state; }
    void setState(const string & s) { state = s; }
};

class Originator
{
    string state;
    //....
public:
    Originator() {}

    Memento createMomento() {
        Memento m(state);
        return m;
    }

    void setMomento(const Memento & m) {
        state = m.getState();
    }
};

int main()
{
    Originator orginator;

    //捕获对象状态，存储到备忘录
    Memento mem = orginator.createMomento();

    //... 改变orginator状态
    //从备忘录中恢复
    orginator.setMomento(mem);
}
```

### 状态模式

```c++
// state.cpp
class NetworkState{

public:
    NetworkState* pNext;
    virtual void Operation1()=0;
    virtual void Operation2()=0;
    virtual void Operation3()=0;

    virtual ~NetworkState(){}
};

class OpenState :public NetworkState{

    static NetworkState* m_instance;
public:
    static NetworkState* getInstance(){
        if (m_instance == nullptr) {
            m_instance = new OpenState();
        }
        return m_instance;
    }

    void Operation1(){

        //**********
        pNext = CloseState::getInstance();
    }

    void Operation2(){

        //..........
        pNext = ConnectState::getInstance();
    }

    void Operation3(){

        //$$$$$$$$$$
        pNext = OpenState::getInstance();
    }
};

class CloseState:public NetworkState{ }
//...

class NetworkProcessor{

    NetworkState* pState;

public:

    NetworkProcessor(NetworkState* pState){

        this->pState = pState;
    }

    void Operation1(){
        //...
        pState->Operation1();
        pState = pState->pNext;
        //...
    }

    void Operation2(){
        //...
        pState->Operation2();
        pState = pState->pNext;
        //...
    }

    void Operation3(){
        //...
        pState->Operation3();
        pState = pState->pNext;
        //...
    }

};
```

### 访问者模式

```c++
// Visitor1.cpp
#include < iostream>
using namespace std;

class Visitor;

class Element
{
public:
    virtual void accept(Visitor& visitor) = 0; //第一次多态辨析

    virtual ~Element(){}
};

class ElementA : public Element
{
public:
    void accept(Visitor &visitor) override {
        visitor.visitElementA(*this);
    }
};

class ElementB : public Element
{
public:
    void accept(Visitor &visitor) override {
        visitor.visitElementB(*this); //第二次多态辨析
    }

};

class Visitor{
public:
    virtual void visitElementA(ElementA& element) = 0;
    virtual void visitElementB(ElementB& element) = 0;

    virtual ~Visitor(){}
};

//=============上边是稳定的部分=====================

//扩展1
class Visitor1 : public Visitor{
public:
    void visitElementA(ElementA& element) override{
        cout << "Visitor1 is processing ElementA" << endl;
    }

    void visitElementB(ElementB& element) override{
        cout << "Visitor1 is processing ElementB" << endl;
    }
};

//扩展2
class Visitor2 : public Visitor{
public:
    void visitElementA(ElementA& element) override{
        cout << "Visitor2 is processing ElementA" << endl;
    }

    void visitElementB(ElementB& element) override{
        cout << "Visitor2 is processing ElementB" << endl;
    }
};

int main()
{
    Visitor2 visitor;
    ElementB elementB;
    elementB.accept(visitor);// double dispatch

    ElementA elementA;
    elementA.accept(visitor);

    return 0;
}
```

```c++
// Visitor2.cpp
#include <iostream>
using namespace std;

class Visitor;

class Element
{
public:
    virtual void Func1() = 0;

    virtual void Func2(int data)=0;
    virtual void Func3(int data)=0;
    //...

    virtual ~Element(){}
};

class ElementA : public Element
{
public:
    void Func1() override{
        //...
    }

    void Func2(int data) override{
        //...
    }
};

class ElementB : public Element
{
public:
    void Func1() override{
        //***
    }

    void Func2(int data) override {
        //***
    }

};
```

### 中介者模式

### 解释器模式

```c++
// interpreter.cpp
// 解决的问题：如果一种特定类型的问题发生的频率足够高，就可将该问题的各个实例表述为一个简单语言中的句子，
//             如果可将该语言中的句子表示为一个抽象语法树时，则可使用解释器模式。
//             构建一个解释器，该解释器通过解释这些句子来解决该问题。
// 不足：解释器模式为文法中的每一条规则至少定义了一个类，因此包含许多规则的文法可能难以管理和维护。
//       建议当文法非常复杂时，使用其他的技术如语法分析程序或编译器生成器来处理。

#include < iostream>
#include < map>
#include < stack>

using namespace std;

// 表达式抽象基类
class Expression {
public:
    virtual int interpreter(map< char, int> var)=0;
    virtual ~Expression(){}

};

//变量表达式
class VarExpression: public Expression {

    char key;

public:
    VarExpression(const char& key) {
        this->key = key;
    }

    int interpreter(map< char, int> var) {
        return var[key];
    }

};

//符号表达式
class SymbolExpression : public Expression {

    // 运算符左右两个参数
protected:
    Expression* left;
    Expression* right;

public:
    SymbolExpression( Expression* left,  Expression* right):
        left(left),right(right){
    }
};

//加法运算
class AddExpression : public SymbolExpression {

public:
    AddExpression(Expression* left, Expression* right):
        SymbolExpression(left,right){

    }
    int interpreter(map< char, int> var) {
        return left->interpreter(var) + right->interpreter(var);
    }
};

//减法运算
class SubExpression : public SymbolExpression {

public:
    SubExpression(Expression* left, Expression* right):
        SymbolExpression(left,right){

    }
    int interpreter(map< char, int> var) {
        return left->interpreter(var) - right->interpreter(var);
    }

};

// 语法分析
Expression*  analyse(string expStr) {

    stack< Expression*> expStack;
    Expression* left = NULL;
    Expression* right = NULL;
    for(int i=0; i < expStr.size(); i++)
    {
        switch(expStr[i])
        {
            case '+':
                // 加法运算
                left = expStack.top();
                right = new VarExpression(expStr[++i]);
                expStack.push(new AddExpression(left, right));
                cout << "add=" << expStr[i] << endl;
                break;
            case '-':
                // 减法运算
                left = expStack.top();
                right = new VarExpression(expStr[++i]);
                expStack.push(new SubExpression(left, right));
                cout << "sub=" << expStr[i] << endl;
                break;
            default:
                // 变量表达式
                cout << "var=" << expStr[i] << endl;
                expStack.push(new VarExpression(expStr[i]));
        }
    }

    Expression* expression = expStack.top();

    return expression;
}

void release(Expression* expression){

    //释放表达式树的节点内存...
}

int main(int argc, const char * argv[]) {

    string expStr = "a+b-c+d-e";
    map< char, int> var;
    var.insert(make_pair('a',5));
    var.insert(make_pair('b',2));
    var.insert(make_pair('c',1));
    var.insert(make_pair('d',6));
    var.insert(make_pair('e',10));
  
    Expression* expression= analyse(expStr);

    int result=expression->interpreter(var);

    cout << result << endl;

    release(expression);

    return 0;
}

// 面向对象的方式解决简单的文法表示：
// 例如：
//     string s1="肆仟叁佰伍拾陆" 转换为数字
```

# 其他

* UML类图学习链接：
    <http://www.uml.org.cn/oobject/201211231.asp>

  总结各类设计模式的类图

* 工厂方法+工厂模式+抽象工厂模式的区别：
    <https://blog.csdn.net/jerry11112/article/details/80618420>
